"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlConnectionPool = void 0;
// import * as core from './core';
// tslint:disable no-bitwise
// tslint:disable-next-line no-require-imports
const _dbg = require("debug");
const SqlConnectionPoolDatabase_1 = require("./SqlConnectionPoolDatabase");
const SqlDatabase_1 = require("./SqlDatabase");
const debug = _dbg('sqlite3orm:pool');
/**
 * A simple connection pool
 *
 * @export
 * @class SqlConnectionPool
 */
class SqlConnectionPool {
    /**
     * Creates an instance of SqlConnectionPool.
     *
     */
    constructor(name = '') {
        this.name = name;
        this.databaseFile = undefined;
        this.mode = SqlDatabase_1.SQL_OPEN_DEFAULT;
        this.inUse = new Set();
        this.inPool = [];
        this.min = this.max = 0;
    }
    get poolSize() {
        return this.inPool.length;
    }
    get openSize() {
        return this.inUse.size;
    }
    /**
     * Open a database connection pool
     *
     * @param databaseFile - The path to the database file or URI
     * @param [mode=SQL_OPEN_DEFAULT] - A bit flag combination of: SQL_OPEN_CREATE |
     * SQL_OPEN_READONLY | SQL_OPEN_READWRITE
     * @param [min=1] minimum connections which should be opened by this connection pool
     * @param [max=0] maximum connections which can be opened by this connection pool
     * @returns A promise
     */
    open(databaseFile, mode = SqlDatabase_1.SQL_OPEN_DEFAULT, min = 1, max = 0, settings) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._opening) {
                try {
                    yield this._opening;
                    if (this.databaseFile === databaseFile && (mode & ~SqlDatabase_1.SQL_OPEN_CREATE) === this.mode) {
                        // already opened
                        return;
                    }
                }
                catch (err) { }
            }
            this._opening = this.openInternal(databaseFile, mode, min, max, settings);
            try {
                yield this._opening;
            }
            catch (err) {
                return Promise.reject(err);
            }
            finally {
                this._opening = undefined;
            }
            return;
        });
    }
    openInternal(databaseFile, mode = SqlDatabase_1.SQL_OPEN_DEFAULT, min = 1, max = 0, settings) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.close();
            }
            catch (err) { }
            try {
                this.databaseFile = databaseFile;
                this.mode = mode;
                this.min = min;
                this.max = max;
                this.settings = settings;
                this.inPool.length = 0;
                const promises = [];
                if (this.min < 1) {
                    this.min = 1;
                }
                let sqldb = new SqlConnectionPoolDatabase_1.SqlConnectionPoolDatabase();
                yield sqldb.openByPool(this, this.databaseFile, this.mode, this.settings);
                this.inPool.push(sqldb);
                this.mode &= ~SqlDatabase_1.SQL_OPEN_CREATE;
                for (let i = 1; i < this.min; i++) {
                    sqldb = new SqlConnectionPoolDatabase_1.SqlConnectionPoolDatabase();
                    promises.push(sqldb.openByPool(this, this.databaseFile, this.mode, this.settings));
                    this.inPool.push(sqldb);
                }
                yield Promise.all(promises);
                if (this.name.length) {
                    SqlConnectionPool.openNamedPools.set(this.name, this);
                }
                debug(`pool ${this.name}: opened: ${this.inUse.size} connections open (${this.inPool.length} in pool)`);
            }
            catch (err) {
                try {
                    yield this.close();
                }
                catch (_ignore) { }
                debug(`pool ${this.name}: opening ${databaseFile} failed: ${err.message}`);
                return Promise.reject(err);
            }
        });
    }
    /**
     * Close the database connection pool
     *
     * @returns A promise
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.databaseFile) {
                    if (this.inUse.size) {
                        debug(`pool ${this.name}: closing: forcibly closing ${this.inUse.size} opened connections (${this.inPool.length} in pool)`);
                    }
                    else {
                        debug(`pool ${this.name}: closing: ${this.inUse.size} connections open (${this.inPool.length} in pool)`);
                    }
                }
                if (this.name.length) {
                    SqlConnectionPool.openNamedPools.delete(this.name);
                }
                this.databaseFile = undefined;
                this.mode = SqlDatabase_1.SQL_OPEN_DEFAULT;
                const promises = [];
                this.inPool.forEach((value) => {
                    promises.push(value.closeByPool());
                });
                this.inPool.length = 0;
                this.inUse.forEach((value) => {
                    promises.push(value.closeByPool());
                });
                this.inUse.clear();
                yield Promise.all(promises);
            }
            catch (err) /* istanbul ignore next */ {
                debug(`pool ${this.name}: closing failed: ${err.message}`);
                return Promise.reject(err);
            }
        });
    }
    /**
     * test if this connection pool is connected to a database file
     */
    isOpen() {
        return !!this.databaseFile;
    }
    /**
     * get a connection from the pool
     *
     * @param [timeout=0] The timeout to wait for a connection ( 0 is infinite )
     * @returns A promise of the db connection
     */
    get(timeout = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let sqldb;
                const cond = () => this.inPool.length > 0;
                if (this.max > 0 && !cond() && this.inUse.size >= this.max) {
                    yield wait(cond, timeout);
                }
                if (this.inPool.length > 0) {
                    // tslint:disable-next-line no-unnecessary-type-assertion
                    sqldb = this.inPool.shift();
                    this.inUse.add(sqldb);
                    debug(`pool ${this.name}: ${this.inUse.size} connections open (${this.inPool.length} in pool)`);
                    return sqldb;
                }
                if (!this.databaseFile) {
                    throw new Error(`connection pool not opened`);
                }
                sqldb = new SqlConnectionPoolDatabase_1.SqlConnectionPoolDatabase();
                yield sqldb.openByPool(this, this.databaseFile, this.mode, this.settings);
                this.inUse.add(sqldb);
                debug(`pool ${this.name}: ${this.inUse.size} connections open (${this.inPool.length} in pool)`);
                return sqldb;
            }
            catch (err) {
                debug(`pool ${this.name}: getting connection from pool failed: ${err.message}`);
                return Promise.reject(err);
            }
        });
    }
    /**
     * release a connection to the pool
     *
     * @param sqldb - The db connection
     */
    release(sqldb) {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!(sqldb instanceof SqlConnectionPoolDatabase_1.SqlConnectionPoolDatabase) || this !== sqldb.pool) {
                // not opened by this pool
                return sqldb.close();
            }
            this.inUse.delete(sqldb);
            /* istanbul ignore else */
            if (sqldb.isOpen()) {
                if (sqldb.dirty || this.inPool.length >= this.min) {
                    // close database connection
                    yield sqldb.closeByPool();
                }
                else {
                    // transfer database connection
                    const newsqldb = new SqlConnectionPoolDatabase_1.SqlConnectionPoolDatabase();
                    yield newsqldb.recycleByPool(this, sqldb, this.settings);
                    this.inPool.push(newsqldb);
                }
                debug(`pool ${this.name}: ${this.inUse.size} connections open (${this.inPool.length} in pool)`);
            }
        });
    }
}
exports.SqlConnectionPool = SqlConnectionPool;
// tslint:disable member-ordering
SqlConnectionPool.openNamedPools = new Map();
// TODO: move this function or find a better one:
function wait(cond, timeout = 0, intervall = 100) {
    return new Promise((resolve, reject) => {
        let counter = 0;
        const timer = setInterval(() => {
            if (cond()) {
                clearInterval(timer);
                resolve();
                return;
            }
            if (timeout > 0 && ++counter * intervall >= timeout) {
                clearInterval(timer);
                debug(`getting connection timed out`);
                reject(new Error('timeout reached'));
                return;
            }
        }, intervall);
    });
}
//# sourceMappingURL=SqlConnectionPool.js.map