"use strict";
// import * as core from './core';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlDatabase = exports.SQL_OPEN_DEFAULT = exports.SQL_MEMORY_DB_SHARED = exports.SQL_MEMORY_DB_PRIVATE = exports.SQL_DEFAULT_SCHEMA = exports.SQL_OPEN_CREATE = exports.SQL_OPEN_READWRITE = exports.SQL_OPEN_READONLY = void 0;
// tslint:disable-next-line no-require-imports
const _dbg = require("debug");
const sqlite3_1 = require("sqlite3");
const SqlStatement_1 = require("./SqlStatement");
exports.SQL_OPEN_READONLY = sqlite3_1.OPEN_READONLY;
exports.SQL_OPEN_READWRITE = sqlite3_1.OPEN_READWRITE;
exports.SQL_OPEN_CREATE = sqlite3_1.OPEN_CREATE;
exports.SQL_DEFAULT_SCHEMA = 'main';
exports.SQL_MEMORY_DB_PRIVATE = ':memory:';
// shared memory database is currently not supported by node-sqlite3
//   see: https://github.com/mapbox/node-sqlite3/issues/710
// but can be enabled by building node-sqlite3 and sqlite3 from source
// see docs/enable-URI.md
exports.SQL_MEMORY_DB_SHARED = 'file:sqlite3orm?mode=memory&cache=shared';
const debug = _dbg('sqlite3orm:database');
// tslint:disable-next-line: no-bitwise
exports.SQL_OPEN_DEFAULT = exports.SQL_OPEN_READWRITE | exports.SQL_OPEN_CREATE;
/**
 * A thin wrapper for the 'Database' class from 'node-sqlite3' using Promises
 * instead of callbacks
 * see
 * https://github.com/mapbox/node-sqlite3/wiki/API
 *
 * see why we may want to have a connection pool running on nodejs serving multiple requests
 * https://github.com/mapbox/node-sqlite3/issues/304
 *
 * @export
 * @class SqlDatabase
 */
class SqlDatabase {
    /**
     * Creates an instance of SqlDatabase.
     *
     */
    constructor() { }
    /**
     * Open a database connection
     *
     * @param databaseFile - The path to the database file or URI
     * @param [mode=SQL_OPEN_DEFAULT] - A bit flag combination of: SQL_OPEN_CREATE |
     * SQL_OPEN_READONLY | SQL_OPEN_READWRITE
     * @returns A promise
     */
    open(databaseFile, mode, settings) {
        return new Promise((resolve, reject) => {
            const db = new sqlite3_1.Database(databaseFile, mode || exports.SQL_OPEN_DEFAULT, (err) => {
                if (err) {
                    debug(`opening connection to ${databaseFile} failed: ${err.message}`);
                    reject(err);
                }
                else {
                    this.db = db;
                    this.dbId = SqlDatabase.lastId++;
                    debug(`${this.dbId}: opened`);
                    resolve();
                }
            });
        }).then(() => {
            if (settings) {
                return this.applySettings(settings);
            }
            return Promise.resolve();
        });
    }
    /**
     * Close the database connection
     *
     * @returns {Promise<void>}
     */
    close() {
        return new Promise((resolve, reject) => {
            if (!this.db) {
                resolve();
            }
            else {
                const db = this.db;
                debug(`${this.dbId}: close`);
                this.db = undefined;
                this.dbId = undefined;
                db.close((err) => {
                    db.removeAllListeners();
                    /* istanbul ignore if */
                    if (err) {
                        debug(`closing connection failed: ${err.message}`);
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    }
    /**
     * Test if a connection is open
     *
     * @returns {boolean}
     */
    isOpen() {
        return !!this.db;
    }
    /**
     * Runs a SQL statement with the specified parameters
     *
     * @param sql - The SQL statment
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    run(sql, params) {
        return new Promise((resolve, reject) => {
            // trace('run stmt=' + sql);
            // trace('>input: ' + JSON.stringify(params));
            /* istanbul ignore if */
            if (!this.db) {
                reject(new Error('database connection not open'));
                return;
            }
            // tslint:disable-next-line: only-arrow-functions
            debug(`${this.dbId}: sql: ${sql}`);
            const self = this;
            this.db.run(sql, params, function (err) {
                // do not use arrow function for this callback
                // the below 'this' should not reference our self
                if (err) {
                    debug(`${self.dbId}: failed sql: ${err.message}
${sql}\nparams: `, params);
                    reject(err);
                }
                else {
                    // tslint:disable-next-line: no-invalid-this
                    const res = { lastID: this.lastID, changes: this.changes };
                    resolve(res);
                }
            });
        });
    }
    /**
     * Runs a SQL query with the specified parameters, fetching only the first row
     *
     * @param sql - The DQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    get(sql, params) {
        return new Promise((resolve, reject) => {
            // trace('get stmt=' + sql);
            // trace('>input: ' + JSON.stringify(params));
            /* istanbul ignore if */
            if (!this.db) {
                reject(new Error('database connection not open'));
                return;
            }
            debug(`${this.dbId}: sql: ${sql}`);
            this.db.get(sql, params, (err, row) => {
                if (err) {
                    debug(`${this.dbId}: failed sql: ${err.message}
${sql}`);
                    reject(err);
                }
                else {
                    // trace('>succeeded: ' + JSON.stringify(row));
                    resolve(row);
                }
            });
        });
    }
    /**
     * Runs a SQL query with the specified parameters, fetching all rows
     *
     * @param sql - The DQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    all(sql, params) {
        return new Promise((resolve, reject) => {
            // trace('all stmt=' + sql);
            // trace('>input: ' + JSON.stringify(params));
            /* istanbul ignore if */
            if (!this.db) {
                reject(new Error('database connection not open'));
                return;
            }
            debug(`${this.dbId}: sql: ${sql}`);
            this.db.all(sql, params, (err, rows) => {
                if (err) {
                    debug(`${this.dbId}: failed sql: ${err.message}
${sql}`);
                    reject(err);
                }
                else {
                    // trace('>succeeded: ' + JSON.stringify(rows));
                    resolve(rows);
                }
            });
        });
    }
    /**
     * Runs a SQL query with the specified parameters, fetching all rows
     * using a callback for each row
     *
     * @param sql - The DQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @param [callback] - The callback function
     * @returns A promise
     */
    each(sql, params, callback) {
        return new Promise((resolve, reject) => {
            /* istanbul ignore if */
            if (!this.db) {
                reject(new Error('database connection not open'));
                return;
            }
            debug(`${this.dbId}: sql: ${sql}`);
            this.db.each(sql, params, callback, (err, count) => {
                if (err) {
                    debug(`${this.dbId}: failed sql: ${err.message}
${sql}`);
                    reject(err);
                }
                else {
                    resolve(count);
                }
            });
        });
    }
    /**
     * Execute a SQL statement
     *
     * @param sql - The SQL statement
     * @returns A promise
     */
    exec(sql) {
        return new Promise((resolve, reject) => {
            // trace('exec stmt=' + sql);
            /* istanbul ignore if */
            if (!this.db) {
                reject(new Error('database connection not open'));
                return;
            }
            debug(`${this.dbId}: sql: ${sql}`);
            this.db.exec(sql, (err) => {
                if (err) {
                    debug(`${this.dbId}: failed sql: ${err.message}
${sql}`);
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Prepare a SQL statement
     *
     * @param sql - The SQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    prepare(sql, params) {
        return new Promise((resolve, reject) => {
            /* istanbul ignore if */
            if (!this.db) {
                reject(new Error('database connection not open'));
                return;
            }
            let dbstmt;
            debug(`${this.dbId}: sql: ${sql}`);
            dbstmt = this.db.prepare(sql, params, (err) => {
                if (err) {
                    debug(`${this.dbId}: failed sql: ${err.message}
${sql}`);
                    reject(err);
                }
                else {
                    resolve(new SqlStatement_1.SqlStatement(dbstmt));
                }
            });
        });
    }
    /**
     * serialized sqlite3 calls
     * if callback is provided, run callback in serialized mode
     * otherwise, switch connection to serialized mode
     *
     * @param [callback]
     */
    serialize(callback) {
        /* istanbul ignore if */
        if (!this.db) {
            throw new Error('database connection not open');
        }
        return this.db.serialize(callback);
    }
    /**
     * parallelized sqlite3 calls
     * if callback is provided, run callback in parallel mode
     * otherwise, switch connection to parallel mode
     *
     * @param [callback]
     */
    parallelize(callback) {
        /* istanbul ignore if */
        if (!this.db) {
            throw new Error('database connection not open');
        }
        return this.db.parallelize(callback);
    }
    /**
     * Run callback inside a database transaction
     *
     * @param [callback]
     */
    transactionalize(callback) {
        return this.run('BEGIN IMMEDIATE TRANSACTION')
            .then(callback)
            .then((res) => this.run('COMMIT TRANSACTION').then(() => Promise.resolve(res)))
            .catch((err) => this.run('ROLLBACK TRANSACTION').then(() => Promise.reject(err)));
    }
    /**
     *
     *
     * @param event
     * @param listener
     */
    on(event, listener) {
        /* istanbul ignore if */
        if (!this.db) {
            throw new Error('database connection not open');
        }
        this.db.on(event, listener);
        return this;
    }
    /**
     * Get the 'user_version' from the database
     * @returns A promise of the user version number
     */
    getUserVersion() {
        return this.get('PRAGMA user_version').then((res) => res.user_version);
    }
    /**
     * Set the 'user_version' in the database
     *
     * @param newver
     * @returns A promise
     */
    setUserVersion(newver) {
        return this.exec(`PRAGMA user_version = ${newver}`);
    }
    /**
     * Get the 'cipher_version' from the database
     * @returns A promise of the cipher version
     */
    getCipherVersion() {
        return this.get('PRAGMA cipher_version').then((res) => 
        /* istanbul ignore next */ res ? res.cipher_version : undefined);
    }
    // tslint:disable-next-line: cyclomatic-complexity
    applySettings(settings) {
        /* istanbul ignore if */
        if (!this.db) {
            return Promise.reject(new Error('database connection not open'));
        }
        const promises = [];
        try {
            /* istanbul ignore if */
            if (settings.cipherCompatibility) {
                this._addPragmaSetting(promises, 'cipher_compatibility', settings.cipherCompatibility);
            }
            /* istanbul ignore if */
            if (settings.key) {
                this._addPragmaSetting(promises, 'key', settings.key);
            }
            /* istanbul ignore else */
            if (settings.journalMode) {
                this._addPragmaSchemaSettings(promises, 'journal_mode', settings.journalMode);
            }
            /* istanbul ignore else */
            if (settings.busyTimeout) {
                this._addPragmaSetting(promises, 'busy_timeout', settings.busyTimeout);
            }
            /* istanbul ignore else */
            if (settings.synchronous) {
                this._addPragmaSchemaSettings(promises, 'synchronous', settings.synchronous);
            }
            /* istanbul ignore else */
            if (settings.caseSensitiveLike) {
                this._addPragmaSetting(promises, 'case_sensitive_like', settings.caseSensitiveLike);
            }
            /* istanbul ignore else */
            if (settings.foreignKeys) {
                this._addPragmaSetting(promises, 'foreign_keys', settings.foreignKeys);
            }
            /* istanbul ignore else */
            if (settings.ignoreCheckConstraints) {
                this._addPragmaSetting(promises, 'ignore_check_constraints', settings.ignoreCheckConstraints);
            }
            /* istanbul ignore else */
            if (settings.queryOnly) {
                this._addPragmaSetting(promises, 'query_only', settings.queryOnly);
            }
            /* istanbul ignore else */
            if (settings.readUncommitted) {
                this._addPragmaSetting(promises, 'read_uncommitted', settings.readUncommitted);
            }
            /* istanbul ignore else */
            if (settings.recursiveTriggers) {
                this._addPragmaSetting(promises, 'recursive_triggers', settings.recursiveTriggers);
            }
            /* istanbul ignore else */
            if (settings.secureDelete) {
                this._addPragmaSchemaSettings(promises, 'secure_delete', settings.secureDelete);
            }
            if (settings.executionMode) {
                switch (settings.executionMode.toUpperCase()) {
                    case 'SERIALIZE':
                        this.serialize();
                        break;
                    case 'PARALLELIZE':
                        this.parallelize();
                        break;
                    default:
                        throw new Error(`failed to read executionMode setting: ${settings.executionMode.toString()}`);
                }
            }
            else {
                this.parallelize();
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
        if (promises.length) {
            return Promise.all(promises).then(() => { });
        }
        return Promise.resolve();
    }
    _addPragmaSchemaSettings(promises, pragma, setting) {
        if (Array.isArray(setting)) {
            setting.forEach((val) => {
                this._addPragmaSetting(promises, pragma, val, true);
            });
        }
        else {
            this._addPragmaSetting(promises, pragma, setting, true);
        }
    }
    _addPragmaSetting(promises, pragma, setting, schemaSupport = false) {
        if (typeof setting === 'number') {
            promises.push(this.exec(`PRAGMA ${pragma} = ${setting}`));
            return;
        }
        if (schemaSupport) {
            const splitted = setting.split('.');
            switch (splitted.length) {
                case 1:
                    promises.push(this.exec(`PRAGMA ${pragma} = ${setting.toUpperCase()}`));
                    return;
                case 2:
                    promises.push(this.exec(`PRAGMA ${splitted[0]}.${pragma} = ${splitted[1].toUpperCase()}`));
                    return;
            }
            throw new Error(`failed to read ${pragma} setting: ${setting.toString()}`);
        }
        else {
            promises.push(this.exec(`PRAGMA ${pragma} = ${setting}`));
        }
    }
    /**
     * Set the execution mode to verbose to produce long stack traces. There is no way to reset this.
     * See https://github.com/mapbox/node-sqlite3/wiki/Debugging
     *
     * @param newver
     */
    static verbose() {
        sqlite3_1.verbose();
    }
}
exports.SqlDatabase = SqlDatabase;
SqlDatabase.lastId = 0;
//# sourceMappingURL=SqlDatabase.js.map