"use strict";
// import * as core from './core';
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlStatement = void 0;
/**
 * A thin wrapper for the 'Statement' class from 'node-sqlite3' using Promises instead of callbacks
 * see
 * https://github.com/mapbox/node-sqlite3/wiki/API
 *
 * @export
 * @class SqlStatement
 */
class SqlStatement {
    /**
     * Creates an instance of SqlStatement.
     *
     * @param stmt
     */
    constructor(stmt) {
        this.stmt = stmt;
    }
    /**
     * Bind the given parameters to the prepared statement
     *
     * @param params
     */
    bind(...params) {
        this.stmt.bind(params);
        return this;
    }
    /**
     * Reset a open cursor of the prepared statement preserving the parameter binding
     * Allows re-execute of the same query
     *
     * @returns {Promise<void>}
     */
    reset() {
        return new Promise((resolve, reject) => {
            this.stmt.reset(() => {
                resolve();
            });
        });
    }
    /**
     * Finalizes a prepared statement ( freeing any resource used by this statement )
     *
     * @returns {Promise<void>}
     */
    finalize() {
        return new Promise((resolve, reject) => {
            this.stmt.finalize((err) => {
                if (err) {
                    /* istanbul ignore next */
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Runs a prepared statement with the specified parameters
     *
     * @param [params] - The parameters referenced in the statement; you can provide multiple parameters as array
     * @returns A promise
     */
    run(params) {
        return new Promise((resolve, reject) => {
            // tslint:disable-next-line: only-arrow-functions
            this.stmt.run(params, function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    // tslint:disable-next-line: no-invalid-this
                    const res = { lastID: this.lastID, changes: this.changes };
                    resolve(res);
                }
            });
        });
    }
    /**
     * Runs a prepared statement with the specified parameters, fetching only the first row
     *
     * @param [params] - The parameters referenced in the statement; you can provide multiple parameters as array
     * @returns A promise
     */
    get(params) {
        return new Promise((resolve, reject) => {
            this.stmt.get(params, (err, row) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(row);
                }
            });
        });
    }
    /**
     * Runs a prepared statement with the specified parameters, fetching all rows
     *
     * @param [params] - The parameters referenced in the statement; you can provide multiple parameters as array
     * @returns A promise
     */
    all(params) {
        return new Promise((resolve, reject) => {
            this.stmt.all(params, (err, rows) => {
                /* istanbul ignore if */
                if (err) {
                    reject(err);
                }
                else {
                    resolve(rows);
                }
            });
        });
    }
    /**
     * Runs a prepared statement with the specified parameters, fetching all rows
     * using a callback for each row
     *
     * @param [params]
     * @param [callback]
     * @returns A promise
     */
    each(params, callback) {
        return new Promise((resolve, reject) => {
            this.stmt.each(params, callback, (err, count) => {
                /* istanbul ignore if */
                if (err) {
                    reject(err);
                }
                else {
                    resolve(count);
                }
            });
        });
    }
}
exports.SqlStatement = SqlStatement;
//# sourceMappingURL=SqlStatement.js.map