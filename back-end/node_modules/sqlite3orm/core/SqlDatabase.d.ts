import { Database } from 'sqlite3';
import { SqlDatabaseSettings } from './SqlDatabaseSettings';
import { SqlRunResult, SqlStatement } from './SqlStatement';
export declare const SQL_OPEN_READONLY: number;
export declare const SQL_OPEN_READWRITE: number;
export declare const SQL_OPEN_CREATE: number;
export declare const SQL_DEFAULT_SCHEMA = "main";
export declare const SQL_MEMORY_DB_PRIVATE = ":memory:";
export declare const SQL_MEMORY_DB_SHARED = "file:sqlite3orm?mode=memory&cache=shared";
export declare const SQL_OPEN_DEFAULT: number;
/**
 * A thin wrapper for the 'Database' class from 'node-sqlite3' using Promises
 * instead of callbacks
 * see
 * https://github.com/mapbox/node-sqlite3/wiki/API
 *
 * see why we may want to have a connection pool running on nodejs serving multiple requests
 * https://github.com/mapbox/node-sqlite3/issues/304
 *
 * @export
 * @class SqlDatabase
 */
export declare class SqlDatabase {
    protected static lastId: number;
    protected db?: Database;
    protected dbId?: number;
    dirty?: boolean;
    /**
     * Creates an instance of SqlDatabase.
     *
     */
    constructor();
    /**
     * Open a database connection
     *
     * @param databaseFile - The path to the database file or URI
     * @param [mode=SQL_OPEN_DEFAULT] - A bit flag combination of: SQL_OPEN_CREATE |
     * SQL_OPEN_READONLY | SQL_OPEN_READWRITE
     * @returns A promise
     */
    open(databaseFile: string, mode?: number, settings?: SqlDatabaseSettings): Promise<void>;
    /**
     * Close the database connection
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Test if a connection is open
     *
     * @returns {boolean}
     */
    isOpen(): boolean;
    /**
     * Runs a SQL statement with the specified parameters
     *
     * @param sql - The SQL statment
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    run(sql: string, params?: any): Promise<SqlRunResult>;
    /**
     * Runs a SQL query with the specified parameters, fetching only the first row
     *
     * @param sql - The DQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    get(sql: string, params?: any): Promise<any>;
    /**
     * Runs a SQL query with the specified parameters, fetching all rows
     *
     * @param sql - The DQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    all(sql: string, params?: any): Promise<any[]>;
    /**
     * Runs a SQL query with the specified parameters, fetching all rows
     * using a callback for each row
     *
     * @param sql - The DQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @param [callback] - The callback function
     * @returns A promise
     */
    each(sql: string, params?: any, callback?: (err: Error, row: any) => void): Promise<number>;
    /**
     * Execute a SQL statement
     *
     * @param sql - The SQL statement
     * @returns A promise
     */
    exec(sql: string): Promise<void>;
    /**
     * Prepare a SQL statement
     *
     * @param sql - The SQL statement
     * @param [params] - The parameters referenced in the statement; you can
     * provide multiple parameters as array
     * @returns A promise
     */
    prepare(sql: string, params?: any): Promise<SqlStatement>;
    /**
     * serialized sqlite3 calls
     * if callback is provided, run callback in serialized mode
     * otherwise, switch connection to serialized mode
     *
     * @param [callback]
     */
    serialize(callback?: () => void): void;
    /**
     * parallelized sqlite3 calls
     * if callback is provided, run callback in parallel mode
     * otherwise, switch connection to parallel mode
     *
     * @param [callback]
     */
    parallelize(callback?: () => void): void;
    /**
     * Run callback inside a database transaction
     *
     * @param [callback]
     */
    transactionalize<T>(callback: () => Promise<T>): Promise<T>;
    /**
     *
     * @param event
     * @param listener
     */
    on(event: 'trace', listener: (sql: string) => void): this;
    /**
     *
     *
     * @param event
     * @param listener
     */
    on(event: 'profile', listener: (sql: string, time: number) => void): this;
    /**
     *
     *
     * @param event
     * @param listener
     */
    on(event: 'error', listener: (err: Error) => void): this;
    /**
     *
     *
     * @param event
     * @param listener
     */
    on(event: 'close', listener: () => void): this;
    /**
     * Get the 'user_version' from the database
     * @returns A promise of the user version number
     */
    getUserVersion(): Promise<number>;
    /**
     * Set the 'user_version' in the database
     *
     * @param newver
     * @returns A promise
     */
    setUserVersion(newver: number): Promise<void>;
    /**
     * Get the 'cipher_version' from the database
     * @returns A promise of the cipher version
     */
    getCipherVersion(): Promise<string | undefined>;
    protected applySettings(settings: SqlDatabaseSettings): Promise<void>;
    protected _addPragmaSchemaSettings(promises: Promise<void>[], pragma: string, setting: string | string[]): void;
    protected _addPragmaSetting(promises: Promise<void>[], pragma: string, setting: string | number, schemaSupport?: boolean): void;
    /**
     * Set the execution mode to verbose to produce long stack traces. There is no way to reset this.
     * See https://github.com/mapbox/node-sqlite3/wiki/Debugging
     *
     * @param newver
     */
    static verbose(): void;
}
