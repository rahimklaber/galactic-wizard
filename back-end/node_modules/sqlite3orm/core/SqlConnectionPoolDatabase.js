"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlConnectionPoolDatabase = void 0;
// tslint:disable-next-line no-require-imports
const _dbg = require("debug");
const sqlite3_1 = require("sqlite3");
const SqlDatabase_1 = require("./SqlDatabase");
const debug = _dbg('sqlite3orm:database');
class SqlConnectionPoolDatabase extends SqlDatabase_1.SqlDatabase {
    close() {
        if (this.pool) {
            return this.pool.release(this);
        }
        else {
            return super.close();
        }
    }
    open(databaseFile, mode, settings) {
        const _super = Object.create(null, {
            close: { get: () => super.close },
            open: { get: () => super.open }
        });
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore else */
            if (this.isOpen()) {
                /* istanbul ignore else */
                if (this.pool) {
                    // stealing from pool
                    // this connection should not be recycled by the pool
                    // => temporary mark as dirty
                    const oldDirty = this.dirty;
                    this.dirty = true;
                    yield this.pool.release(this);
                    this.dirty = oldDirty;
                }
                else {
                    yield _super.close.call(this);
                }
            }
            this.pool = undefined;
            return _super.open.call(this, databaseFile, mode, settings);
        });
    }
    /*
    @internal
    */
    openByPool(pool, databaseFile, mode, settings) {
        return new Promise((resolve, reject) => {
            const db = new sqlite3_1.Database(databaseFile, mode || SqlDatabase_1.SQL_OPEN_DEFAULT, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    this.pool = pool;
                    this.db = db;
                    this.dbId = SqlDatabase_1.SqlDatabase.lastId++;
                    debug(`${this.dbId}: opened`);
                    resolve();
                }
            });
        }).then(() => {
            if (settings) {
                return this.applySettings(settings);
            }
            return Promise.resolve();
        });
    }
    /*
    @internal
    */
    closeByPool() {
        this.pool = undefined;
        return new Promise((resolve, reject) => {
            /* istanbul ignore if */
            if (!this.db) {
                resolve();
            }
            else {
                const db = this.db;
                debug(`${this.dbId}: close`);
                this.db = undefined;
                this.dbId = undefined;
                db.close((err) => {
                    db.removeAllListeners();
                    /* istanbul ignore if */
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    }
    /*
    @internal
    */
    recycleByPool(pool, sqldb, settings) {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore else */
            if (sqldb.db) {
                sqldb.db.removeAllListeners();
                // move
                this.db = sqldb.db;
                this.dbId = sqldb.dbId;
                this.pool = pool;
                // reapply default settings
                if (settings) {
                    try {
                        yield this.applySettings(settings);
                    }
                    catch (err) { }
                }
            }
            sqldb.db = undefined;
            sqldb.dbId = undefined;
            sqldb.pool = undefined;
        });
    }
}
exports.SqlConnectionPoolDatabase = SqlConnectionPoolDatabase;
//# sourceMappingURL=SqlConnectionPoolDatabase.js.map