"use strict";
// tslint:disable callable-types
// tslint:disable-next-line: no-import-side-effect
// import * as core from './core';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDAO = exports.BaseDAOInsertMode = void 0;
const metadata_1 = require("./metadata");
const query_1 = require("./query");
/**
 *
 * @export
 * @enum
 */
var BaseDAOInsertMode;
(function (BaseDAOInsertMode) {
    /** use the provided value if defined, otherwise let sqlite generate the value automatically */
    BaseDAOInsertMode[BaseDAOInsertMode["StrictSqlite"] = 1] = "StrictSqlite";
    /** prevents the insertion of predefined primary key values; always let sqlite generate a value automatically */
    BaseDAOInsertMode[BaseDAOInsertMode["ForceAutoGeneration"] = 2] = "ForceAutoGeneration";
})(BaseDAOInsertMode = exports.BaseDAOInsertMode || (exports.BaseDAOInsertMode = {}));
/**
 *
 *
 * @export
 * @class BaseDAO
 * @template T - The class mapped to the base table
 */
class BaseDAO {
    /**
     * Creates an instance of BaseDAO.
     *
     * @param type - The class mapped to the base table
     * @param sqldb - The database connection
     */
    constructor(type, sqldb) {
        this.type = type;
        this.metaModel = Reflect.getMetadata(metadata_1.METADATA_MODEL_KEY, type.prototype);
        if (!this.metaModel) {
            throw new Error(`no table-definition defined on prototype of ${this.type.name}'`);
        }
        this.table = this.metaModel.table;
        this.sqldb = sqldb;
        this.queryModel = new query_1.QueryModel(this.type);
    }
    /**
     * insert
     *
     * @param model - A model class instance
     * @returns A promise of the inserted model class instance
     */
    insert(model, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.insertInternal(model, undefined, mode);
        });
    }
    /**
     * insert partially - insert only columns mapped to the property keys from the partial input model
     *
     * for this to work:
     * all columns mapped to included properties must be nullable or their properties must provide a value
     * all columns mapped to excluded properties must be nullable or must have a database default value
     *
     * @param input - A model class instance
     * @returns A promise of the inserted model class instance
     */
    insertPartial(input, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = Object.keys(input);
            return this.insertInternal(input, keys, mode);
        });
    }
    /**
     * replace ( insert or replace )
     *
     * @param model - A model class instance
     * @returns A promise of the inserted or updated model class instance
     */
    replace(model) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.insertOrReplaceInternal(model);
        });
    }
    /**
     * replace ( insert or replace ) partially
     *
     * for this to work:
     * all columns mapped to included properties must be nullable or their properties must provide a value
     * all columns mapped to excluded properties must be nullable or must have a database default value
     *
     * @param input - A model class instance
     * @returns A promise of the inserted or updated model class instance
     */
    replacePartial(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = Object.keys(input);
            return this.insertOrReplaceInternal(input, keys);
        });
    }
    /**
     * update
     *
     * @param model - A model class instance
     * @returns A promise of the updated model class instance
     */
    update(model) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.updateInternal(model);
        });
    }
    /**
     * update partially - update only columns mapped to the property keys from the partial input model
     *
     * for this to work:
     * all columns mapped to included properties must be nullable or their properties must provide a value
     * all other columns are not affected by this update
     *
     * @param input - A model class instance
     * @returns A promise of the updated model class instance
     */
    updatePartial(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = Object.keys(input);
            return this.updateInternal(input, keys);
        });
    }
    /**
     * update all - please provide a proper sql-condition otherwise all records will be updated!
     * this updates only columns mapped to the property keys from the partial input model
     *
     * for this to work:
     * all columns mapped to included properties must be nullable or their properties must provide a value
     * all other columns are not affected by this update
     *
     * @param input - A model class instance
     * @param [where] - An optional Where-object or sql-text which will be added to the update-statement
     *                    e.g 'WHERE <your condition>'
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of the updated model class instance
     */
    updatePartialAll(input, where, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const keys = Object.keys(input);
                let sql = this.queryModel.getUpdateAllStatement(keys);
                params = Object.assign({}, this.queryModel.bindAllInputParams(input, keys), params);
                const whereClause = yield this.queryModel.getWhereClause(this.toFilter(where), params);
                sql += `  ${whereClause}`;
                const res = yield this.sqldb.run(sql, params);
                if (!res.changes) {
                    return Promise.reject(new Error(`update '${this.table.name}' failed: nothing changed`));
                }
                return res.changes;
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`update '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * delete using primary key
     *
     * @param model - A model class instance
     * @returns A promise
     */
    delete(model) {
        return this.deleteById(model);
    }
    /**
     * delete using primary key
     *
     * @param input - A partial model class instance
     * @returns A promise
     */
    deleteById(input) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.sqldb.run(this.queryModel.getDeleteByIdStatement(), this.queryModel.bindPrimaryKeyInputParams(input));
                if (!res.changes) {
                    return Promise.reject(new Error(`delete from '${this.table.name}' failed: nothing changed`));
                }
            }
            catch (e) {
                // NOTE: should not happen
                /* istanbul ignore next */
                return Promise.reject(new Error(`delete from '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * delete all - please provide a proper sql-condition otherwise all records will be deleted!
     *
     * @param [where] - An optional Where-object or sql-text which will be added to the delete-statement
     *                    e.g 'WHERE <your condition>'
     * @param [params] - An optional object with additional host parameter
     * @returns A promise
     */
    deleteAll(where, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let sql = this.queryModel.getDeleteAllStatement();
                params = Object.assign({}, params);
                const whereClause = yield this.queryModel.getWhereClause(this.toFilter(where), params);
                sql += `  ${whereClause}`;
                const res = yield this.sqldb.run(sql, params);
                if (!res.changes) {
                    return Promise.reject(new Error(`delete from '${this.table.name}' failed: nothing changed`));
                }
                return Promise.resolve(res.changes);
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`delete from '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * Select a given model
     *
     * @param model - The input/output model
     * @returns A promise of the model instance
     */
    select(model) {
        return this.queryModel.selectModel(this.sqldb, model);
    }
    /**
     * select using primary key
     *
     * @param input - A partial model class instance
     * @returns A promise of the model instance
     */
    selectById(input) {
        return this.queryModel.selectModelById(this.sqldb, input);
    }
    /**
     * select parent by using a foreign key constraint and a given child instance
     *
     * @template C - The class mapped to the child table
     * @param constraintName - The foreign key constraint (defined in the child table)
     * @param childType - The class mapped to the childtable
     * @param childObj - An instance of the class mapped to the child table
     * @returns A promise of model instance
     */
    selectByChild(constraintName, childType, childObj) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: refactor to use QueryModel and a Where object
            // create child DAO
            const childDAO = new BaseDAO(childType, this.sqldb);
            let output;
            try {
                // get child properties
                const fkProps = childDAO.queryModel.getForeignKeyProps(constraintName);
                const cols = childDAO.queryModel.getForeignKeyRefCols(constraintName);
                /* istanbul ignore if */
                if (!fkProps || !cols) {
                    throw new Error(`in '${childDAO.metaModel.name}': constraint '${constraintName}' is not defined`);
                }
                const refNotFoundCols = [];
                // get parent (our) properties
                const props = this.queryModel.getPropertiesFromColumnNames(cols, refNotFoundCols);
                /* istanbul ignore if */
                if (!props || refNotFoundCols.length) {
                    const s = '"' + refNotFoundCols.join('", "') + '"';
                    throw new Error(`in '${this.metaModel.name}': no property mapped to these fields: ${s}`);
                }
                // bind parameters
                const hostParams = {};
                for (let i = 0; i < fkProps.length; ++i) {
                    this.queryModel.setHostParamValue(hostParams, props[i], fkProps[i].getDBValueFromModel(childObj));
                }
                // generate statement
                let stmt = this.queryModel.getSelectAllStatement(undefined, query_1.TABLEALIAS);
                stmt += '\nWHERE\n  ';
                stmt += props
                    .map((prop) => `${query_1.TABLEALIAS}.${prop.field.quotedName}=${prop.getHostParameterName()}`)
                    .join(' AND ');
                const row = yield this.sqldb.get(stmt, hostParams);
                output = this.queryModel.updateModelFromRow(new this.type(), row);
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
            return output;
        });
    }
    /**
     * select parent by using a foreign key constraint and a given child instance
     *
     * @template P - The class mapped to the parent table
     * @param constraintName - The foreign key constraint (defined in the child table)
     * @param parentType - The class mapped to the parent table
     * @param childObj - An instance of the class mapped to the child table
     * @returns A promise of model instance
     */
    selectParentOf(constraintName, parentType, childObj) {
        const parentDAO = new BaseDAO(parentType, this.sqldb);
        return parentDAO.selectByChild(constraintName, this.type, childObj);
    }
    /**
     * Select all models using an optional filter
     *
     * @param [whereOrFilter] - An optional Where/Filter-object or
     *                          sql-text which will be added to the select-statement
     *                             e.g 'WHERE <your condition>'
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of array of model instances
     */
    selectAll(whereOrFilter, params) {
        return this.queryModel.selectAll(this.sqldb, this.toFilter(whereOrFilter, query_1.TABLEALIAS), params);
    }
    /**
     * Select all partial models using a filter
     *
     * @param filter - A Filter-object
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of array of model instances
     */
    selectPartialAll(filter, params) {
        return this.queryModel.selectPartialAll(this.sqldb, filter, params);
    }
    /**
     * select all childs using a foreign key constraint and a given parent instance
     *
     * @template P - The class mapped to the parent table
     * @param constraintName - The foreign key constraint
     * @param parentType - The class mapped to the parent table
     * @param parentObj - An instance of the class mapped to the parent table
     * @param [whereOrFilter] - An optional Where/Filter-object or sql-text which will be added to the select-statement
     *                    e.g 'WHERE <your condition>'
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of array of model instances
     */
    selectAllOf(constraintName, parentType, parentObj, whereOrFilter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // TODO: refactor to use QueryModel and a Where object
                const fkPredicates = this.queryModel.getForeignKeyPredicates(constraintName);
                if (!fkPredicates) {
                    throw new Error(`constraint '${constraintName}' is not defined`);
                }
                let stmt = this.queryModel.getSelectAllStatement(undefined, query_1.TABLEALIAS);
                stmt += '\nWHERE\n';
                stmt += `  ${query_1.TABLEALIAS}.` + fkPredicates.join(` AND ${query_1.TABLEALIAS}.`);
                if (whereOrFilter) {
                    stmt += ' ';
                    stmt += whereOrFilter;
                }
                const parentDAO = new BaseDAO(parentType, this.sqldb);
                const childParams = this.queryModel.bindForeignParams(parentDAO.queryModel, constraintName, parentObj, params);
                const rows = yield this.sqldb.all(stmt, childParams);
                const results = [];
                rows.forEach((row) => {
                    results.push(this.queryModel.updateModelFromRow(new this.type(), row));
                });
                return results;
            }
            catch (e) {
                return Promise.reject(new Error(`select '${this.table.name}' failed: ${e.message}`));
            }
        });
    }
    /**
     * select all childs using a foreign key constraint and a given parent instance
     *
     * @template C - The class mapped to the child table
     * @param constraintName - The foreign key constraint (defined in the child table)
     * @param childType - The class mapped to the childtable
     * @param parentObj - An instance of the class mapped to the parent table
     * @param [where] - An optional Where/Filter-object or sql-text which will be added to the select-statement
     *                    e.g 'WHERE <your condition>'
     * @param [params] - An optional object with additional host parameter
     * @returns A promise of array of model instances
     */
    selectAllChildsOf(constraintName, childType, parentObj, where, params) {
        const childDAO = new BaseDAO(childType, this.sqldb);
        return childDAO.selectAllOf(constraintName, this.type, parentObj, where, params);
    }
    /**
     * perform:
     * select T.<col1>,.. FROM <table> T
     *
     * @param callback - The callback called for each row
     * @param [whereOrFilter] - An optional Where/Filter-object or sql-text which will be added to the select-statement
     *                     e.g 'WHERE <your condition>'
     * @param [params] - An optional object with additional host parameter
     * @returns A promise
     */
    selectEach(callback, whereOrFilter, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryModel.selectEach(this.sqldb, callback, this.toFilter(whereOrFilter, query_1.TABLEALIAS), params);
        });
    }
    /**
     * create a table in the database
     *
     * @returns {Promise<void>}
     */
    createTable(force) {
        return this.sqldb.exec(this.table.getCreateTableStatement(force));
    }
    /**
     * drop a table from the database
     *
     * @returns {Promise<void>}
     */
    dropTable() {
        return this.sqldb.exec(this.table.getDropTableStatement());
    }
    /**
     * add a column/field to a database table
     *
     * @param colName - The column/field to add
     * @returns A promise
     */
    alterTableAddColumn(colName) {
        return this.sqldb.exec(this.table.getAlterTableAddColumnStatement(colName));
    }
    /**
     * create index in the database
     *
     * @param idxName - The name of the index
     * @param [unique] - create unique index
     * @returns A promise
     */
    createIndex(idxName, unique) {
        return this.sqldb.exec(this.table.getCreateIndexStatement(idxName, unique));
    }
    /**
     * drop an index from the database
     *
     * @param idxName - The name of the index
     * @returns A promise
     */
    dropIndex(idxName) {
        return this.sqldb.exec(this.table.getDropIndexStatement(idxName));
    }
    toFilter(whereOrFilter, tableAlias) {
        if (whereOrFilter && query_1.isFilter(whereOrFilter)) {
            return whereOrFilter;
        }
        return { where: whereOrFilter, tableAlias };
    }
    insertInternal(input, keys, mode) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const insertMode = mode || ((_a = BaseDAO.options) === null || _a === void 0 ? void 0 : _a.insertMode);
                const stmt = this.queryModel.getInsertIntoStatement(keys);
                const params = this.queryModel.bindAllInputParams(input, keys);
                const idProperty = this.table.rowIdField
                    ? this.metaModel.mapColNameToProp.get(this.table.rowIdField.name)
                    : undefined;
                if (idProperty &&
                    // tslint:disable-next-line: triple-equals
                    idProperty.getDBValueFromModel(input) != undefined) {
                    if ((insertMode === undefined && this.table.autoIncrementField) ||
                        insertMode === BaseDAOInsertMode.ForceAutoGeneration) {
                        // tslint:disable-next-line: no-null-keyword
                        params[idProperty.getHostParameterName()] = null;
                    }
                }
                const res = yield this.sqldb.run(stmt, params);
                if (idProperty) {
                    /* istanbul ignore if */
                    // tslint:disable-next-line: triple-equals
                    if (res.lastID == undefined) {
                        // NOTE: should not happen
                        const operation = this.table.autoIncrementField ? 'AUTOINCREMENT' : 'ROWID';
                        return Promise.reject(new Error(`insert into '${this.table.name}' using ${operation} failed: 'lastID' is null or undefined`));
                    }
                    // tslint:disable-next-line: no-non-null-assertion
                    res[this.table.rowIdField.name] = res.lastID;
                    /* istanbul ignore else */
                    idProperty.setDBValueIntoModel(input, res.lastID);
                }
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`insert into '${this.table.name}' failed: ${e.message}`));
            }
            return input;
        });
    }
    insertOrReplaceInternal(input, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.sqldb.run(this.queryModel.getInsertOrReplaceStatement(keys), this.queryModel.bindAllInputParams(input, keys));
                if (this.table.autoIncrementField) {
                    /* istanbul ignore if */
                    // tslint:disable-next-line: triple-equals
                    if (res.lastID == undefined) {
                        // NOTE: should not happen
                        return Promise.reject(new Error("replace into '${this.table.name}' failed: autoincrement failed"));
                    }
                    const autoProp = this.metaModel.mapColNameToProp.get(this.table.autoIncrementField.name);
                    /* istanbul ignore else */
                    if (autoProp) {
                        autoProp.setDBValueIntoModel(input, res.lastID);
                    }
                }
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(new Error(`replace into '${this.table.name}' failed: ${e.message}`));
            }
            return input;
        });
    }
    updateInternal(input, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.sqldb.run(this.queryModel.getUpdateByIdStatement(keys), this.queryModel.bindAllInputParams(input, keys, true));
                if (!res.changes) {
                    return Promise.reject(new Error(`update '${this.table.name}' failed: nothing changed`));
                }
            }
            catch (e) {
                return Promise.reject(new Error(`update '${this.table.name}' failed: ${e.message}`));
            }
            return input;
        });
    }
}
exports.BaseDAO = BaseDAO;
// BaseDAO.options = { insertMode: BaseDAOInsertMode.StrictSqlite };
// BaseDAO.options = { insertMode: BaseDAOInsertMode.ForceAutoGeneration };
//# sourceMappingURL=BaseDAO.js.map