"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoUpgrader = exports.UpgradeMode = void 0;
// tslint:disable-next-line no-require-imports
const _dbg = require("debug");
const dbcatalog_1 = require("./dbcatalog");
const metadata_1 = require("./metadata");
const utils_1 = require("./utils");
const debug = _dbg('sqlite3orm:autoupgrade');
var UpgradeMode;
(function (UpgradeMode) {
    UpgradeMode[UpgradeMode["ACTUAL"] = 0] = "ACTUAL";
    UpgradeMode[UpgradeMode["CREATE"] = 1] = "CREATE";
    UpgradeMode[UpgradeMode["ALTER"] = 2] = "ALTER";
    UpgradeMode[UpgradeMode["RECREATE"] = 3] = "RECREATE";
})(UpgradeMode = exports.UpgradeMode || (exports.UpgradeMode = {}));
class AutoUpgrader {
    constructor(sqldb) {
        this.sqldb = sqldb;
        this.catalogDao = new dbcatalog_1.DbCatalogDAO(sqldb);
    }
    /*
     * upgrade all registered tables
     */
    /* istanbul ignore next */
    upgradeAllTables(opts) {
        return this.upgradeTables(metadata_1.schema().getAllTables(), opts);
    }
    /*
     * upgrade specified tables
     */
    upgradeTables(tables, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let fkEnabled;
            let error;
            // set fkEnabled and if foreign key constraints are enabled, disable them
            try {
                fkEnabled = yield this.foreignKeyEnabled();
                if (fkEnabled) {
                    yield this.foreignKeyEnable(false);
                }
            }
            catch (e /* istanbul ignore next */) {
                return Promise.reject(e);
            }
            // upgrade tables
            try {
                if (Array.isArray(tables)) {
                    yield utils_1.sequentialize(tables.map((table) => () => this._upgradeTable(table, opts)));
                }
                else {
                    yield this._upgradeTable(tables, opts);
                }
            }
            catch (e) {
                error = e;
            }
            // If foreign key constraints were originally enabled, enable them again
            if (fkEnabled) {
                try {
                    yield this.foreignKeyEnable(true);
                }
                catch (e /* istanbul ignore next */) {
                    if (!error) {
                        error = e;
                    }
                }
            }
            if (error) {
                return Promise.reject(error);
            }
        });
    }
    isActual(tables, opts) {
        const promises = [];
        if (Array.isArray(tables)) {
            tables.forEach((tab) => {
                promises.push(this.getUpgradeInfo(tab, opts).then((info) => info.upgradeMode === UpgradeMode.ACTUAL));
            });
        }
        else {
            promises.push(this.getUpgradeInfo(tables, opts).then((info) => info.upgradeMode === UpgradeMode.ACTUAL));
        }
        return Promise.all(promises).then((results) => results.reduce((prev, curr) => prev && curr));
    }
    getUpgradeInfo(table, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let tableInfo;
            try {
                tableInfo = yield this.catalogDao.readTableInfo(table.name);
            }
            catch (err /* istanbul ignore next */) {
                return Promise.reject(err);
            }
            return this._getUpgradeInfo(table, tableInfo, opts);
        });
    }
    // tslint:disable cyclomatic-complexity
    _getUpgradeInfo(table, tableInfo, opts) {
        opts =
            AutoUpgrader.defaults || opts ? Object.assign({}, AutoUpgrader.defaults, opts) : undefined;
        if (!tableInfo) {
            debug(`  does not exist`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.CREATE };
        }
        if (opts && opts.forceRecreate) {
            debug(`  forcing recreate`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
        }
        // test if foreign key definitions are equal, otherwise return UpgradeMode.RECREATE
        if (table.mapNameToFKDef.size !== Object.keys(tableInfo.foreignKeys).length) {
            debug(`  foreign key added or removed`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
        }
        for (const fk of table.mapNameToFKDef.values()) {
            const genName = metadata_1.FKDefinition.genericForeignKeyId(fk.fields.map((f) => f.name), fk.foreignTableName, fk.fields.map((field) => field.foreignColumnName));
            if (!tableInfo.foreignKeys[genName]) {
                debug(`  foreign key definition for '${fk.name}' changed`);
                return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
            }
        }
        // test if no column needs to be dropped, otherwise return UpgradeMode.RECREATE
        const keepOldColumns = opts && opts.keepOldColumns ? true : false;
        let oldColumnsCount = 0;
        for (const colName of Object.keys(tableInfo.columns)) {
            const field = table.mapNameToField.get(colName);
            if (!field) {
                if (!keepOldColumns || tableInfo.columns[colName].notNull) {
                    if (keepOldColumns) {
                        debug(`  column to keep '${colName} as nullable'`);
                    }
                    else {
                        debug(`  column dropped '${colName}'`);
                    }
                    return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
                }
                else {
                    oldColumnsCount += 1;
                    debug(`  column to keep '${colName}'`);
                    continue;
                }
            }
            const newFldDef = metadata_1.Field.parseDbType(field.dbtype);
            if (!newFldDef ||
                newFldDef.typeAffinity !== tableInfo.columns[colName].typeAffinity ||
                newFldDef.notNull !== tableInfo.columns[colName].notNull ||
                // tslint:disable-next-line triple-equals
                newFldDef.defaultValue != tableInfo.columns[colName].defaultValue) {
                debug(`  column changed '${colName}'`);
                // debug(`    old: `, JSON.stringify(tableInfo.columns[colName]));
                // debug(`    new: `, JSON.stringify(newFldDef));
                return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
            }
        }
        // test if primary key columns are equal, otherwise return UpgradeMode.RECREATE
        if (table.mapNameToIdentityField.size !== tableInfo.primaryKey.length) {
            debug(`  primary key column added or removed`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
        }
        let pkIdx = 0;
        for (const fld of table.fields) {
            if (!table.mapNameToIdentityField.has(fld.name)) {
                continue;
            }
            if (fld.name !== tableInfo.primaryKey[pkIdx++]) {
                debug(`  primary key column changed`);
                return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
            }
        }
        // test if autoIncrement is equal, otherwise return UpgradeMode.RECREATE
        if ((table.autoIncrementField && !tableInfo.autoIncrement) ||
            (!table.autoIncrementField && tableInfo.autoIncrement)) {
            debug(`  autoIncrement changed`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.RECREATE };
        }
        // test if no column needs to be added, otherwise return UpgradeMode.ALTER
        if (Object.keys(tableInfo.columns).length - oldColumnsCount !== table.fields.length) {
            debug(`  column(s) added`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.ALTER };
        }
        // test if no index needs to be changed, otherwise return UpgradeMode.ALTER
        if (Object.keys(tableInfo.indexes).length !== table.mapNameToIDXDef.size) {
            debug(`  indexes added or removed`);
            return { tableInfo, opts, upgradeMode: UpgradeMode.ALTER };
        }
        for (const name of Object.keys(tableInfo.indexes)) {
            const idx = table.mapNameToIDXDef.get(utils_1.qualifiySchemaIdentifier(name, tableInfo.schemaName));
            if (!idx) {
                debug(`  index '${name}' dropped`);
                return { tableInfo, opts, upgradeMode: UpgradeMode.ALTER };
            }
            const oldCols = tableInfo.indexes[name].columns.map((idxCol) => idxCol.name).join(',');
            const newCols = idx.fields.map((fld) => fld.name).join(',');
            if (oldCols !== newCols) {
                debug(`  index '${name}' changed`);
                // debug(`     old: ${oldCols}`);
                // debug(`     new: ${newCols}`);
                return { tableInfo, opts, upgradeMode: UpgradeMode.ALTER };
            }
        }
        // tslint:enable cyclomatic-complexity
        return { tableInfo, opts, upgradeMode: UpgradeMode.ACTUAL };
    }
    _upgradeTable(table, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`upgradeTable(${table.name}):`);
            let upgradeInfo;
            try {
                upgradeInfo = yield this.getUpgradeInfo(table, opts);
            }
            catch (err /* istanbul ignore next */) {
                return Promise.reject(err);
            }
            switch (upgradeInfo.upgradeMode) {
                case UpgradeMode.ACTUAL:
                    return;
                case UpgradeMode.CREATE:
                    return this.createTable(table);
                case UpgradeMode.ALTER:
                    return this.alterTable(table, upgradeInfo);
                case UpgradeMode.RECREATE:
                    return this.recreateTable(table, upgradeInfo);
                /* istanbul ignore next */
                default:
                    return Promise.reject(`table '${table.name}': unknown upgrade-mode detected`);
            }
        });
    }
    /*
     * create table and indexes
     */
    createTable(table) {
        const factories = [];
        debug(`  => create table`);
        // create table
        factories.push(() => this.sqldb.exec(table.getCreateTableStatement(true)));
        // create all indexes
        table.mapNameToIDXDef.forEach((idx) => {
            debug(`  => create index '${idx.name}'`);
            factories.push(() => this.sqldb.exec(table.getCreateIndexStatement(idx.name)));
        });
        return utils_1.sequentialize(factories).then(() => { });
    }
    /*
     * alter table and add missing table colums and indexes
     */
    alterTable(table, upgradeInfo) {
        const tableInfo = upgradeInfo.tableInfo;
        const factories = [];
        debug(`  => alter table`);
        // add missing columns
        table.mapNameToField.forEach((field) => {
            if (!tableInfo.columns[field.name]) {
                debug(`  => alter table add column '${field.name}'`);
                factories.push(() => this.sqldb.exec(table.getAlterTableAddColumnStatement(field.name)));
            }
        });
        // drop indexes
        Object.keys(tableInfo.indexes).forEach((name) => {
            const idx = table.mapNameToIDXDef.get(utils_1.qualifiySchemaIdentifier(name, tableInfo.schemaName));
            if (!idx) {
                debug(`  => drop index '${name}'`);
                factories.push(() => this.sqldb.exec(`DROP INDEX IF EXISTS ${utils_1.quoteIdentifier(name)}`));
                delete tableInfo.indexes[name]; // delete to enable re-creation
                return;
            }
            const oldCols = tableInfo.indexes[name].columns.map((idxCol) => idxCol.name).join(',');
            const newCols = idx.fields.map((fld) => fld.name).join(',');
            if (oldCols !== newCols) {
                debug(`  => drop index '${name}' (changed)`);
                // debug(`     oldCols='${oldCols}'`);
                // debug(`     newCols='${newCols}'`);
                factories.push(() => this.sqldb.exec(`DROP INDEX IF EXISTS ${utils_1.quoteIdentifier(name)}`));
                delete tableInfo.indexes[name]; // delete to enable re-creation
                return;
            }
        });
        // add missing indexes
        table.mapNameToIDXDef.forEach((idx) => {
            if (!tableInfo.indexes[idx.name]) {
                debug(`  => create index '${idx.name}'`);
                factories.push(() => this.sqldb.exec(table.getCreateIndexStatement(idx.name)));
            }
        });
        return utils_1.sequentialize(factories).then(() => { });
    }
    /*
     * recreate table
     */
    recreateTable(table, upgradeInfo) {
        const tableInfo = upgradeInfo.tableInfo;
        const addFields = [];
        const factories = [];
        debug(`  => recreate table`);
        const keepOldColumns = upgradeInfo.opts && upgradeInfo.opts.keepOldColumns ? true : false;
        if (keepOldColumns) {
            for (const colName of Object.keys(tableInfo.columns)) {
                const field = table.mapNameToField.get(colName);
                if (field) {
                    continue;
                }
                const addField = new metadata_1.Field(colName, false);
                // NOTE: these columns should always be nullable
                addField.dbtype = tableInfo.columns[colName].type;
                const defaultValue = tableInfo.columns[colName].defaultValue;
                // tslint:disable-next-line triple-equals
                if (defaultValue != undefined) {
                    addField.dbtype += ` DEFAULT(${defaultValue.toString()})`;
                }
                addFields.push(addField);
            }
        }
        const tmpTableName = utils_1.quoteIdentifier(table.name + '_autoupgrade');
        // rename old table
        factories.push(() => this.sqldb.exec(`ALTER TABLE ${table.quotedName} RENAME TO ${tmpTableName}`));
        // create table
        factories.push(() => this.sqldb.exec(table.createCreateTableStatement(true, addFields)));
        // data transfer
        let colNames;
        if (keepOldColumns) {
            colNames = Object.keys(tableInfo.columns)
                .map((colName) => utils_1.quoteIdentifier(colName))
                .join(',');
        }
        else {
            colNames = Object.keys(tableInfo.columns)
                .filter((colName) => table.mapNameToField.has(colName))
                .map((colName) => utils_1.quoteIdentifier(colName))
                .join(',');
        }
        const insertStmt = `INSERT INTO ${table.quotedName} (
  ${colNames}
) SELECT
  ${colNames}
FROM  ${tmpTableName}`;
        factories.push(() => this.sqldb.exec(insertStmt));
        // drop old table
        factories.push(() => this.sqldb.exec(`DROP TABLE ${tmpTableName}`));
        // create all indexes
        table.mapNameToIDXDef.forEach((idx) => {
            debug(`  => create index '${idx.name}'`);
            factories.push(() => this.sqldb.exec(table.getCreateIndexStatement(idx.name)));
        });
        return this.sqldb.transactionalize(() => utils_1.sequentialize(factories).then(() => { }));
    }
    /*
     * get current foreign key enforcement status
     */
    foreignKeyEnabled() {
        return this.sqldb.get('PRAGMA foreign_keys').then((row) => !!row.foreign_keys);
    }
    /*
     * set current foreign key enforcement status
     */
    foreignKeyEnable(enable) {
        const val = enable ? 'TRUE' : 'FALSE';
        return this.sqldb.exec(`PRAGMA foreign_keys = ${val}`);
    }
    static debug(formatter, ...args) {
        debug(formatter, ...args);
    }
}
exports.AutoUpgrader = AutoUpgrader;
//# sourceMappingURL=AutoUpgrader.js.map