"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = void 0;
const utils_1 = require("../utils");
const dbcatalog_1 = require("../dbcatalog");
const PropertyType_1 = require("./PropertyType");
const Schema_1 = require("./Schema");
/**
 * Class holding a field definition
 *
 * @export
 * @class Field
 */
class Field {
    /**
     * Creates an instance of Field.
     *
     */
    constructor(name, isIdentity, opts, propertyType) {
        this.name = name;
        this.isIdentity = !!isIdentity;
        this.setDbDefaultType(propertyType, opts);
        if (opts) {
            if (opts.dbtype) {
                this.dbtype = opts.dbtype;
            }
            // tslint:disable-next-line triple-equals
            if (opts.isJson != undefined) {
                this._isJson = opts.isJson;
            }
            // tslint:disable-next-line triple-equals
            if (opts.dateInMilliSeconds != undefined) {
                this._dateInMilliSeconds = opts.dateInMilliSeconds;
            }
        }
    }
    /**
     * The quoted field name
     */
    get quotedName() {
        return utils_1.backtickQuoteSimpleIdentifier(this.name);
    }
    get dbDefaultType() {
        return this._dbDefaultType;
    }
    set dbDefaultType(dbType) {
        this._dbDefaultType = dbType;
        if (!this._dbtype) {
            this._dbTypeInfo = Field.parseDbType(this._dbDefaultType);
        }
    }
    get dbtype() {
        return this._dbtype ? this._dbtype : this.dbDefaultType;
    }
    set dbtype(dbType) {
        this._dbtype = dbType;
        this._dbTypeInfo = Field.parseDbType(this._dbtype);
    }
    get isDbTypeDefined() {
        return this._dbtype ? true : false;
    }
    get dbTypeInfo() {
        return this._dbTypeInfo;
    }
    get isJson() {
        // tslint:disable-next-line triple-equals
        return this._isJson == undefined ? false : this._isJson;
    }
    set isJson(isJson) {
        this._isJson = isJson;
    }
    get isIsJsonDefined() {
        // tslint:disable-next-line triple-equals
        return this._isJson == undefined ? false : true;
    }
    get dateInMilliSeconds() {
        // tslint:disable-next-line triple-equals
        return this._dateInMilliSeconds == undefined
            ? Schema_1.schema().dateInMilliSeconds
            : this._dateInMilliSeconds;
    }
    set dateInMilliSeconds(val) {
        this._dateInMilliSeconds = val;
    }
    get isDateInMilliSecondsDefined() {
        // tslint:disable-next-line triple-equals
        return this._dateInMilliSeconds == undefined ? false : true;
    }
    setDbDefaultType(propertyType, opts) {
        switch (propertyType) {
            case PropertyType_1.PropertyType.BOOLEAN:
            case PropertyType_1.PropertyType.DATE:
                if (opts && opts.notNull) {
                    this.dbDefaultType = 'INTEGER NOT NULL';
                }
                else {
                    this.dbDefaultType = 'INTEGER';
                }
                break;
            case PropertyType_1.PropertyType.NUMBER:
                if (this.isIdentity) {
                    this.dbDefaultType = 'INTEGER NOT NULL';
                }
                else {
                    if (opts && opts.notNull) {
                        this.dbDefaultType = 'REAL NOT NULL';
                    }
                    else {
                        this.dbDefaultType = 'REAL';
                    }
                }
                break;
            default:
                // otherwise 'TEXT' will be used as default
                if (opts && opts.notNull) {
                    this.dbDefaultType = 'TEXT NOT NULL';
                }
                else {
                    this.dbDefaultType = 'TEXT';
                }
                break;
        }
    }
    static parseDbType(dbtype) {
        const typeDefMatches = /^\s*((\w+)(\s*\(\s*\d+\s*(,\s*\d+\s*)?\))?)(.*)$/.exec(dbtype);
        /* istanbul ignore if */
        if (!typeDefMatches) {
            throw new Error(`failed to parse '${dbtype}'`);
        }
        const typeAffinity = dbcatalog_1.DbCatalogDAO.getTypeAffinity(typeDefMatches[2]);
        const rest = typeDefMatches[5];
        const notNull = /\bNOT\s+NULL\b/i.exec(rest) ? true : false;
        let defaultValue;
        const defaultNumberMatches = /\bDEFAULT\s+([+-]?\d+(\.\d*)?)/i.exec(rest);
        if (defaultNumberMatches) {
            defaultValue = defaultNumberMatches[1];
        }
        const defaultLiteralMatches = /\bDEFAULT\s+(('[^']*')+)/i.exec(rest);
        if (defaultLiteralMatches) {
            defaultValue = defaultLiteralMatches[1];
            defaultValue.replace(/\'\'/g, "'");
        }
        const defaultExprMatches = /\bDEFAULT\s*\(([^\)]*)\)/i.exec(rest);
        if (defaultExprMatches) {
            defaultValue = defaultExprMatches[1];
        }
        // debug(`dbtype='${dbtype}'`);
        // debug(`type='${typeName}'`);
        // debug(`notNull='${notNull}'`);
        // debug(`default='${defaultValue}'`);
        return { typeAffinity, notNull, defaultValue };
    }
}
exports.Field = Field;
//# sourceMappingURL=Field.js.map