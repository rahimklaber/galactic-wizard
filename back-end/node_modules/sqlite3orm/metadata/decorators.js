"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.index = exports.fk = exports.id = exports.field = exports.table = exports.getModelMetadata = exports.METADATA_MODEL_KEY = void 0;
// tslint:disable-next-line: no-import-side-effect
require("reflect-metadata");
// import * as core from './core';
const MetaModel_1 = require("./MetaModel");
exports.METADATA_MODEL_KEY = 'sqlite3orm:model';
/**
 * Get the model metadata
 *
 * @param target - The constructor of the class
 * @returns The meta model
 */
function getModelMetadata(target) {
    if (!Reflect.hasOwnMetadata(exports.METADATA_MODEL_KEY, target.prototype)) {
        Reflect.defineMetadata(exports.METADATA_MODEL_KEY, new MetaModel_1.MetaModel(target.name), target.prototype);
    }
    return Reflect.getMetadata(exports.METADATA_MODEL_KEY, target.prototype);
}
exports.getModelMetadata = getModelMetadata;
/**
 * Helper function for decorating a class and map it to a database table
 *
 * @param target - The constructor of the class
 * @param [opts] - The options for this table
 */
function decorateTableClass(target, opts) {
    const metaModel = getModelMetadata(target);
    metaModel.init(opts);
}
/**
 * Helper function for decorating a property and map it to a table field
 *
 * @param target - The decorated class
 * @param key - The decorated property
 * @param [opts] - The options for this field
 * @param [isIdentity=false] - Indicator if this field belongs to the
 * primary key
 * @returns The field class instance
 */
function decorateFieldProperty(target, key, opts, isIdentity) {
    if (typeof target === 'function') {
        // not decorating static property
        throw new Error(`decorating static property '${key.toString()}' using field-decorator is not supported`);
    }
    const metaModel = getModelMetadata(target.constructor);
    const metaProp = metaModel.getOrAddProperty(key);
    /* istanbul ignore if */
    if (typeof key === 'number') {
        key = key.toString();
    }
    metaProp.setPropertyType(Reflect.getMetadata('design:type', target, key));
    metaModel.setPropertyField(key, isIdentity, opts);
}
/**
 * Helper function for decorating a property and map it to a foreign key field
 *
 * @param target - The decorated class
 * @param key - The decorated property
 * @param constraintName - The name for the foreign key constraint
 * @param foreignTableName - The referenced table name
 * @param foreignTableField - The referenced table field
 * @returns - The field class instance
 */
function decorateForeignKeyProperty(target, key, constraintName, foreignTableName, foreignTableField) {
    if (typeof target === 'function') {
        // not decorating static property
        throw new Error(`decorating static property '${key.toString()}' using fk-decorator is not supported`);
    }
    const metaModel = getModelMetadata(target.constructor);
    metaModel.setPropertyForeignKey(key, constraintName, foreignTableName, foreignTableField);
}
/**
 * Helper function for decorating a property and map it to an index field
 *
 * @param target - The decorated class
 * @param key - The decorated property
 * @param indexName - The name for the index
 * @param [isUnique] - is a unique index
 * @param [desc] - descending order for this column
 * @returns The field class instance
 */
function decorateIndexProperty(target, key, indexName, isUnique, desc) {
    if (typeof target === 'function') {
        // not decorating static property
        throw new Error(`decorating static property '${key.toString()}' using index-decorator is not supported`);
    }
    const metaModel = getModelMetadata(target.constructor);
    metaModel.setPropertyIndexKey(key, indexName, isUnique, desc);
}
/*****************************************************************************************/
/* decorators:

/**
 * The class decorator for mapping a database table to a class
 *
 * @export
 * @param [opts]
 * @returns The decorator function
 */
function table(opts = {}) {
    return (target) => decorateTableClass(target, opts);
}
exports.table = table;
/**
 * The property decorator for mapping a table field to a class property
 *
 * @export
 * @param [name] - The name of the field; defaults to the property name
 * @param [dbtype] - The type of the field; defaults to 'TEXT'
 * @returns The decorator function
 */
function field(opts = {}) {
    return (target, key) => {
        decorateFieldProperty(target, key, opts, false);
    };
}
exports.field = field;
/**
 * The id decorator for mapping a field of the primary key to a class property
 *
 * @export
 * @param [name] - The name of the field; defaults to the property name
 * @param [dbtype] - The type of the field; defaults to 'TEXT'
 * @returns The decorator function
 */
function id(opts = {}) {
    return (target, key) => {
        decorateFieldProperty(target, key, opts, true);
    };
}
exports.id = id;
/**
 * The fk decorator for mapping a class property to be part of a foreign key
 * constraint
 *
 * @export
 * @param constraintName - The constraint name
 * @param foreignTableName - The referenced table name
 * @param foreignTableField - The referenced table field
 * @returns The decorator function
 */
function fk(constraintName, foreignTableName, foreignTableField) {
    return (target, key) => {
        decorateForeignKeyProperty(target, key, constraintName, foreignTableName, foreignTableField);
    };
}
exports.fk = fk;
/**
 * The index decorator for mapping a class property to be part of an index
 *
 * @export
 * @param indexName - The index name
 * @param [isUnique] - index is unique
 * @param [desc] - descending order for this column
 * @returns The decorator function
 */
function index(indexName, isUnique, desc) {
    return (target, key) => {
        decorateIndexProperty(target, key, indexName, isUnique, desc);
    };
}
exports.index = index;
//# sourceMappingURL=decorators.js.map