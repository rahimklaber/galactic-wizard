"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaModel = void 0;
// import * as core from './core';
const MetaProperty_1 = require("./MetaProperty");
const Schema_1 = require("./Schema");
const FKDefinition_1 = require("./FKDefinition");
const IDXDefinition_1 = require("./IDXDefinition");
class MetaModel {
    constructor(name) {
        this.name = name;
        this.properties = new Map();
        this.mapColNameToProp = new Map();
        this.opts = {};
    }
    get table() {
        /* istanbul ignore else */
        if (this._table) {
            return this._table;
        }
        /* istanbul ignore next */
        throw new Error(`meta model '${this.name}' not fully initialized yet`);
    }
    hasProperty(key) {
        return this.properties.get(key);
    }
    getProperty(key) {
        const prop = this.properties.get(key);
        if (prop) {
            return prop;
        }
        throw new Error(`property '${key.toString()}' not defined for meta model '${this.name}'`);
    }
    getOrAddProperty(key) {
        let prop = this.properties.get(key);
        if (!prop) {
            prop = new MetaProperty_1.MetaProperty(this.name, key);
            this.properties.set(key, prop);
        }
        return prop;
    }
    setPropertyField(key, isIdentity, opts) {
        this.getOrAddProperty(key);
        if (!this.opts.field) {
            this.opts.field = new Map();
        }
        let fieldOpts = this.opts.field.get(key);
        if (fieldOpts) {
            throw new Error(`property '${this.name}.${key.toString()}' already mapped to '${fieldOpts.name}'`);
        }
        fieldOpts = { name: opts.name || key.toString(), isIdentity, opts };
        this.opts.field.set(key, fieldOpts);
    }
    setPropertyForeignKey(key, constraintName, foreignTableName, foreignTableField) {
        this.getOrAddProperty(key);
        if (!this.opts.fk) {
            this.opts.fk = new Map();
        }
        let propertyFkOpts = this.opts.fk.get(key);
        if (!propertyFkOpts) {
            propertyFkOpts = new Map();
            this.opts.fk.set(key, propertyFkOpts);
        }
        if (propertyFkOpts.has(constraintName)) {
            throw new Error(`property '${this.name}.${key.toString()}' already mapped to foreign key '${constraintName}'`);
        }
        propertyFkOpts.set(constraintName, { constraintName, foreignTableName, foreignTableField });
    }
    setPropertyIndexKey(key, indexName, isUnique, desc) {
        this.getOrAddProperty(key);
        if (!this.opts.index) {
            this.opts.index = new Map();
        }
        let propertyIdxOpts = this.opts.index.get(key);
        if (!propertyIdxOpts) {
            propertyIdxOpts = new Map();
            this.opts.index.set(key, propertyIdxOpts);
        }
        if (propertyIdxOpts.has(indexName)) {
            throw new Error(`property '${this.name}.${key.toString()}' already mapped to index '${indexName}'`);
        }
        propertyIdxOpts.set(indexName, { name: indexName, isUnique, desc });
    }
    init(tableOpts) {
        if (this._table) {
            throw new Error(`meta model '${this.name}' already mapped to '${this._table.name}'`);
        }
        const tableName = tableOpts.name || this.name;
        try {
            this._table = Schema_1.schema().getOrAddTable(tableName, tableOpts);
        }
        catch (err) {
            throw new Error(`meta model '${this.name}': failed to add field: ${err.message}`);
        }
        const idxDefs = new Map();
        const fkDefs = new Map();
        // tslint:disable no-non-null-assertion
        /* istanbul ignore if */
        if (!this.opts.field) {
            this.opts.field = new Map();
        }
        // after all the decoraters have run and a table has been created
        // we are able to fully initialize all properties:
        this.properties.forEach((prop, key) => {
            let fieldOpts = this.opts.field.get(key);
            /* istanbul ignore if */
            if (!fieldOpts) {
                fieldOpts = { name: key.toString(), isIdentity: false, opts: {} };
                this.opts.field.set(key, fieldOpts);
            }
            prop.init(this, fieldOpts.name, fieldOpts.isIdentity, fieldOpts.opts);
            const allPropIdxOpts = this.opts.index && this.opts.index.get(key);
            if (allPropIdxOpts) {
                allPropIdxOpts.forEach((propIdxOpts, idxName) => {
                    let idxDef = idxDefs.get(idxName);
                    if (!idxDef) {
                        idxDef = new IDXDefinition_1.IDXDefinition(idxName, propIdxOpts.isUnique);
                        idxDefs.set(idxName, idxDef);
                    }
                    else {
                        // test for conflicting isUniqe setting
                        // tslint:disable triple-equals
                        if (propIdxOpts.isUnique != undefined) {
                            if (idxDef.isUnique != undefined && propIdxOpts.isUnique !== idxDef.isUnique) {
                                throw new Error(`property '${this.name}.${prop.key.toString()}': conflicting index uniqueness setting`);
                            }
                            idxDef.isUnique = propIdxOpts.isUnique;
                        }
                        // tslint:enable triple-equals
                    }
                    idxDef.fields.push({ name: prop.field.name, desc: propIdxOpts.desc });
                });
            }
            const allPropFkOpts = this.opts.fk && this.opts.fk.get(key);
            if (allPropFkOpts) {
                allPropFkOpts.forEach((propFkOpts, constraintName) => {
                    let fkDef = fkDefs.get(constraintName);
                    if (!fkDef) {
                        fkDef = new FKDefinition_1.FKDefinition(constraintName, propFkOpts.foreignTableName);
                        fkDefs.set(constraintName, fkDef);
                    }
                    else {
                        // test for conflicting foreign table setting
                        if (propFkOpts.foreignTableName !== fkDef.foreignTableName) {
                            throw new Error(`property '${this.name}.${prop.key.toString()}': conflicting foreign table setting: new: '${propFkOpts.foreignTableName}', old '${fkDef.foreignTableName}'`);
                        }
                    }
                    fkDef.fields.push({
                        name: prop.field.name,
                        foreignColumnName: propFkOpts.foreignTableField,
                    });
                });
            }
        });
        // tslint:enable no-non-null-assertion
        idxDefs.forEach((idxDef) => {
            this.table.addIDXDefinition(idxDef);
        });
        fkDefs.forEach((fkDef) => {
            this.table.addFKDefinition(fkDef);
        });
        this.table.models.add(this);
        this.opts = {};
    }
    destroy() {
        if (this._table) {
            this._table.models.delete(this);
            if (!this.table.models.size) {
                Schema_1.schema().deleteTable(this._table.name);
            }
            this._table = undefined;
            this.properties = new Map();
            this.mapColNameToProp = new Map();
        }
    }
}
exports.MetaModel = MetaModel;
//# sourceMappingURL=MetaModel.js.map