declare type Primitive = string | number | boolean;
export declare type ComparisonOperatorType = 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'isIn' | 'isNotIn' | 'isBetween' | 'isNotBetween' | 'isLike' | 'isNotLike' | 'isNull' | 'isNotNull';
export interface PropertyComparisons<T> {
    eq?: T | Promise<T>;
    neq?: T | Promise<T>;
    gt?: T | Promise<T>;
    gte?: T | Promise<T>;
    lt?: T | Promise<T>;
    lte?: T | Promise<T>;
    isIn?: T[] | Promise<T[]>;
    isNotIn?: T[] | Promise<T[]>;
    isBetween?: [T | Promise<T>, T | Promise<T>];
    isNotBetween?: [T | Promise<T>, T | Promise<T>];
    isLike?: (T & string) | Promise<T & string>;
    isNotLike?: (T & string) | Promise<T & string>;
    isNull?: boolean;
    isNotNull?: boolean;
}
declare type ShortHandType = Primitive | Date;
export declare type PropertyPredicates<PT> = PropertyComparisons<PT> | (PT & ShortHandType) | Promise<PT & ShortHandType>;
export declare type ModelPredicates<MT> = {
    [K in keyof MT]?: PropertyPredicates<MT[K]>;
} & {
    not?: never;
    or?: never;
    and?: never;
    sql?: never;
};
export declare function getPropertyPredicates<MT, K extends keyof MT>(modelPredicates: ModelPredicates<MT>, key: K): PropertyPredicates<MT[K]>;
export declare function getPropertyComparison<MT, K extends keyof MT>(propertyPredicate: PropertyPredicates<MT[K]>, key: string): any;
export declare type LogicalOperatorType = 'not' | 'or' | 'and' | 'sql';
export declare type Condition<MT> = {
    not: Condition<MT> | ModelPredicates<MT>;
} | {
    or: (Condition<MT> | ModelPredicates<MT>)[];
} | {
    and: (Condition<MT> | ModelPredicates<MT>)[];
} | {
    sql: string;
} | ModelPredicates<MT>;
export declare function isModelPredicates<MT>(cond?: Condition<MT>): cond is ModelPredicates<MT>;
export declare type Where<MT> = Condition<MT> | string;
export {};
