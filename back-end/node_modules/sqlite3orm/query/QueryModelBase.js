"use strict";
// tslint:disable callable-types
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryModelBase = exports.TABLEALIAS = void 0;
const metadata_1 = require("../metadata");
exports.TABLEALIAS = 'T';
class QueryModelBase {
    constructor(type) {
        this.type = type;
        this.metaModel = Reflect.getMetadata(metadata_1.METADATA_MODEL_KEY, type.prototype);
        if (!this.metaModel) {
            throw new Error(`no table-definition defined on prototype of ${this.type.name}'`);
        }
        this.table = this.metaModel.table;
        if (!this.metaModel.qmCache) {
            this.metaModel.qmCache = this.buildCache();
        }
    }
    /**
     * Get 'SELECT ALL'-statement
     *
     * @returns The sql-statement
     */
    getSelectAllStatement(keys, tableAlias) {
        tableAlias = tableAlias || '';
        const tablePrefix = tableAlias.length ? `${tableAlias}.` : '';
        const props = this.getPropertiesFromKeys(keys);
        let stmt = 'SELECT\n';
        stmt +=
            `  ${tablePrefix}` + props.map((prop) => prop.field.quotedName).join(`,\n  ${tablePrefix}`);
        stmt += `\nFROM ${this.table.quotedName} ${tableAlias}\n`;
        return stmt;
    }
    /**
     * Get 'SELECT BY PRIMARY KEY'-statement
     *
     * @returns The sql-statement
     */
    getSelectByIdStatement(keys, tableAlias) {
        const tablePrefix = tableAlias && tableAlias.length ? `${tableAlias}.` : '';
        let stmt = this.getSelectAllStatement(keys, tableAlias);
        stmt += 'WHERE\n';
        stmt +=
            `  ${tablePrefix}` + this.metaModel.qmCache.primaryKeyPredicates.join(` AND ${tablePrefix}`);
        return stmt;
    }
    /**
     * Get 'UPDATE ALL' statement
     *
     * @returns The sql-statement
     */
    getUpdateAllStatement(keys) {
        let props = this.getPropertiesFromKeys(keys);
        props = props.filter((prop) => !prop.field.isIdentity);
        /* istanbul ignore if */
        if (!props.length) {
            throw new Error(`no columns to update'`);
        }
        let stmt = `UPDATE ${this.table.quotedName} SET\n  `;
        stmt += props
            .map((prop) => `${prop.field.quotedName} = ${prop.getHostParameterName()}`)
            .join(',\n  ');
        return stmt;
    }
    /**
     * Get 'UPDATE BY PRIMARY KEY' statement
     *
     * @returns The sql-statement
     */
    getUpdateByIdStatement(keys) {
        let stmt = this.getUpdateAllStatement(keys);
        stmt += '\nWHERE\n  ';
        stmt += this.metaModel.qmCache.primaryKeyPredicates.join(' AND ');
        return stmt;
    }
    /**
     * Get 'DELETE ALL'-statement
     *
     * @returns The sql-statement
     */
    getDeleteAllStatement() {
        return `DELETE FROM ${this.table.quotedName}`;
    }
    /**
     * Get 'DELETE BY PRIMARY KEY'-statement
     *
     * @returns The sql-statement
     */
    getDeleteByIdStatement() {
        let stmt = this.getDeleteAllStatement();
        stmt += '\nWHERE\n  ';
        stmt += this.metaModel.qmCache.primaryKeyPredicates.join(' AND ');
        return stmt;
    }
    /**
     * Get 'INSERT INTO'-statement
     *
     * @returns The sql-statement
     */
    getInsertIntoStatement(keys) {
        const props = this.getPropertiesFromKeys(keys);
        if (!props.length) {
            return `INSERT INTO ${this.table.quotedName} DEFAULT VALUES`;
        }
        let stmt = `INSERT INTO ${this.table.quotedName} (\n  `;
        stmt += props.map((prop) => prop.field.quotedName).join(', ');
        stmt += '\n) VALUES (\n  ';
        stmt += props.map((prop) => prop.getHostParameterName()).join(', ');
        stmt += '\n)';
        return stmt;
    }
    /**
     * Get 'REPLACE INTO'-statement
     *
     * @returns The sql-statement
     */
    getInsertOrReplaceStatement(keys) {
        const props = this.getPropertiesFromKeys(keys);
        if (!props.length) {
            return `INSERT OR REPLACE INTO ${this.table.quotedName} DEFAULT VALUES`;
        }
        let stmt = `INSERT OR REPLACE INTO ${this.table.quotedName} (\n  `;
        stmt += props.map((prop) => prop.field.quotedName).join(', ');
        stmt += '\n) VALUES (\n  ';
        stmt += props.map((prop) => prop.getHostParameterName()).join(', ');
        stmt += '\n)';
        return stmt;
    }
    /**
     * Get a select-condition for a foreign key constraint
     *
     * @param constraintName - The constraint name
     * @returns The partial where-clause
     */
    getForeignKeyPredicates(constraintName) {
        return this.metaModel.qmCache.foreignKeyPredicates.get(constraintName);
    }
    /**
     * Get the foreign key (child) properties for a foreign key constraint
     *
     * @param constraintName - The constraint name
     * @returns The properties holding the foreign key
     */
    getForeignKeyProps(constraintName) {
        return this.metaModel.qmCache.foreignKeyProps.get(constraintName);
    }
    /**
     * Get the reference (parent) columns for a foreign key constraint
     *
     * @param constraintName - The constraint name
     * @returns The referenced column names
     */
    getForeignKeyRefCols(constraintName) {
        return this.metaModel.qmCache.foreignKeyRefCols.get(constraintName);
    }
    getPropertiesFromKeys(keys, addIdentity) {
        if (!keys) {
            return Array.from(this.metaModel.properties.values());
        }
        const res = new Map();
        keys.forEach((key) => {
            const prop = this.metaModel.properties.get(key);
            if (!prop) {
                return;
            }
            res.set(key, prop);
        });
        /* istanbul ignore if */
        if (addIdentity) {
            // for later use
            this.metaModel.qmCache.primaryKeyProps
                .filter((prop) => !res.has(prop.key))
                .forEach((prop) => {
                res.set(prop.key, prop);
            });
        }
        return Array.from(res.values());
    }
    getPropertiesFromColumnNames(cols, notFoundCols) {
        const resProps = [];
        /* istanbul ignore if */
        if (!notFoundCols) {
            notFoundCols = [];
        }
        cols.forEach((colName) => {
            const refProp = this.metaModel.mapColNameToProp.get(colName);
            /* istanbul ignore else */
            if (refProp) {
                resProps.push(refProp);
            }
            else {
                notFoundCols.push(colName);
            }
        });
        /* istanbul ignore if */
        if (notFoundCols.length) {
            return undefined;
        }
        return resProps;
    }
    setHostParam(hostParams, prop, model) {
        hostParams[prop.getHostParameterName()] = prop.getDBValueFromModel(model);
    }
    setHostParamValue(hostParams, prop, value) {
        hostParams[prop.getHostParameterName()] = value;
    }
    updateModelFromRow(model, row) {
        this.metaModel.properties.forEach((prop) => {
            prop.setDBValueIntoModel(model, row[prop.field.name]);
        });
        return model;
    }
    getPartialFromRow(row) {
        const res = {};
        this.metaModel.properties.forEach((prop) => {
            if (row[prop.field.name] !== undefined) {
                prop.setDBValueIntoModel(res, row[prop.field.name]);
            }
        });
        return res;
    }
    bindForeignParams(foreignQueryModel, constraintName, foreignObject, more = {}) {
        const hostParams = Object.assign({}, more);
        const fkProps = this.getForeignKeyProps(constraintName);
        const refCols = this.getForeignKeyRefCols(constraintName);
        /* istanbul ignore if */
        if (!fkProps || !refCols || fkProps.length !== refCols.length) {
            throw new Error(`bind information for '${constraintName}' in table '${this.table.name}' is incomplete`);
        }
        const refNotFoundCols = [];
        const refProps = foreignQueryModel.getPropertiesFromColumnNames(refCols, refNotFoundCols);
        /* istanbul ignore if */
        if (!refProps || refNotFoundCols.length) {
            const s = '"' + refNotFoundCols.join('", "') + '"';
            throw new Error(`in '${foreignQueryModel.metaModel.name}': no property mapped to these fields: ${s}`);
        }
        for (let i = 0; i < fkProps.length; ++i) {
            const fkProp = fkProps[i];
            const refProp = refProps[i];
            this.setHostParamValue(hostParams, fkProp, refProp.getDBValueFromModel(foreignObject));
        }
        return hostParams;
    }
    bindAllInputParams(model, keys, addIdentity) {
        const hostParams = {};
        const props = this.getPropertiesFromKeys(keys, addIdentity);
        props.forEach((prop) => {
            this.setHostParam(hostParams, prop, model);
        });
        return hostParams;
    }
    /* istanbul ignore next */
    // obsolete
    bindNonPrimaryKeyInputParams(model, keys) {
        const hostParams = {};
        const props = this.getPropertiesFromKeys(keys);
        props
            .filter((prop) => !prop.field.isIdentity)
            .forEach((prop) => {
            this.setHostParam(hostParams, prop, model);
        });
        return hostParams;
    }
    bindPrimaryKeyInputParams(model) {
        const hostParams = {};
        this.metaModel.qmCache.primaryKeyProps.forEach((prop) => {
            this.setHostParam(hostParams, prop, model);
        });
        return hostParams;
    }
    buildCache() {
        /* istanbul ignore if */
        if (!this.metaModel.properties.size) {
            throw new Error(`class '${this.metaModel.name}': does not have any mapped properties`);
        }
        // primary key predicates
        const props = Array.from(this.metaModel.properties.values());
        const primaryKeyProps = props.filter((prop) => prop.field.isIdentity);
        const primaryKeyPredicates = primaryKeyProps.map((prop) => `${prop.field.quotedName}=${prop.getHostParameterName()}`);
        // --------------------------------------------------------------
        // generate SELECT-fk condition
        const foreignKeyPredicates = new Map();
        const foreignKeyProps = new Map();
        const foreignKeyRefCols = new Map();
        this.table.mapNameToFKDef.forEach((fkDef, constraintName) => {
            const fkProps = [];
            fkDef.fields.forEach((fkField) => {
                const prop = this.metaModel.mapColNameToProp.get(fkField.name);
                /* istanbul ignore else */
                if (prop) {
                    fkProps.push(prop);
                }
            });
            /* istanbul ignore else */
            if (fkProps.length === fkDef.fields.length) {
                const selectCondition = fkProps.map((prop) => `${prop.field.quotedName}=${prop.getHostParameterName()}`);
                // tslint:disable no-non-null-assertion
                foreignKeyPredicates.set(constraintName, selectCondition);
                foreignKeyProps.set(constraintName, fkProps);
                foreignKeyRefCols.set(constraintName, fkDef.fields.map((field) => field.foreignColumnName));
                // tslint:enable no-non-null-assertion
            }
        });
        return {
            primaryKeyProps,
            primaryKeyPredicates,
            foreignKeyPredicates,
            foreignKeyProps,
            foreignKeyRefCols,
        };
    }
}
exports.QueryModelBase = QueryModelBase;
//# sourceMappingURL=QueryModelBase.js.map