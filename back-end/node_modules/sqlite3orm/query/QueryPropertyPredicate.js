"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryPropertyPredicate = void 0;
class QueryPropertyPredicate {
    constructor(propertyKey, opName, value) {
        this.propertyKey = propertyKey;
        this.value = value;
        switch (opName) {
            case 'eq':
            case 'neq':
            case 'gt':
            case 'gte':
            case 'lt':
            case 'lte':
            case 'isIn':
            case 'isNotIn':
            case 'isBetween':
            case 'isNotBetween':
            case 'isLike':
            case 'isNotLike':
            case 'isNull':
            case 'isNotNull':
                this.op = opName;
                break;
            /* istanbul ignore next */
            default:
                throw new Error(`unknown comparison operation: '${opName}'`);
        }
    }
    toSql(metaModel, params, tablePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const prop = metaModel.getProperty(this.propertyKey);
            let sql = `${tablePrefix}${prop.field.quotedName} `;
            const value = yield this.value;
            sql += this.operatorSql(value);
            switch (this.op) {
                // no host variable:
                case 'isNull':
                case 'isNotNull':
                    return sql;
                // one host variable:
                case 'eq':
                case 'neq':
                case 'gt':
                case 'gte':
                case 'lt':
                case 'lte':
                case 'isLike':
                case 'isNotLike':
                    sql += ' ' + this.setHostParameter(prop, params, prop.valueToDB(value));
                    return sql;
                // two host variables:
                case 'isBetween':
                case 'isNotBetween':
                    /* istanbul ignore if */
                    if (!Array.isArray(value)) {
                        throw new Error(`expected array parameter for BETWEEN-operation on '${this.propertyKey.toString()}`);
                    }
                    /* istanbul ignore if */
                    if (value.length !== 2) {
                        throw new Error(`expected 2-tuple for BETWEEN-operation on '${this.propertyKey.toString()}`);
                    }
                    const from = yield value[0];
                    const to = yield value[1];
                    sql += ' ' + this.setHostParameter(prop, params, prop.valueToDB(from));
                    sql += ' AND ' + this.setHostParameter(prop, params, prop.valueToDB(to));
                    return `(${sql})`;
                // multiple host variables:
                case 'isIn':
                case 'isNotIn':
                    /* istanbul ignore if */
                    if (!Array.isArray(value)) {
                        throw new Error(`expected array parameter for IN-operation on '${this.propertyKey.toString()}`);
                    }
                    if (!value.length) {
                        throw new Error(`expected a value for IN-operation on '${this.propertyKey.toString()}`);
                    }
                    const hostParams = [];
                    for (const item of value) {
                        hostParams.push(this.setHostParameter(prop, params, prop.valueToDB(item)));
                    }
                    sql += ' (' + hostParams.join(', ') + ')';
                    return sql;
                /* istanbul ignore next */
                default:
                    throw new Error(`unknown operation: '${this.op}`);
            }
        });
    }
    operatorSql(value) {
        // add operator
        switch (this.op) {
            case 'isNull':
                return value ? 'ISNULL' : 'NOTNULL';
            case 'isNotNull':
                return value ? 'NOTNULL' : 'ISNULL';
            case 'eq':
                return '=';
            case 'neq':
                return '!=';
            case 'gt':
                return '>';
            case 'gte':
                return '>=';
            case 'lt':
                return '<';
            case 'lte':
                return '<=';
            case 'isLike':
                return 'LIKE';
            case 'isNotLike':
                return 'NOT LIKE';
            case 'isBetween':
                return 'BETWEEN';
            case 'isNotBetween':
                return 'NOT BETWEEN';
            case 'isIn':
                return 'IN';
            case 'isNotIn':
                return 'NOT IN';
            /* istanbul ignore next */
            default:
                throw new Error(`unknown operation: '${this.op}`);
        }
    }
    setHostParameter(prop, params, value) {
        const namePrefix = prop.getHostParameterName('w$');
        let nr = 1;
        let key = `${namePrefix}$`;
        while (params.hasOwnProperty(key)) {
            nr++;
            key = `${namePrefix}$${nr}`;
        }
        params[key] = value;
        return key;
    }
}
exports.QueryPropertyPredicate = QueryPropertyPredicate;
//# sourceMappingURL=QueryPropertyPredicate.js.map